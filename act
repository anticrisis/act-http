#!/bin/sh
# -*- tcl -*- \
command -v tclsh > /dev/null 2>&1 || { echo "Can't find tclsh on your path. Consider invoking as 'path/to/tclsh act ..."; exit 1;} # \
exec tclsh "$0" ${1+"$@"}

#
# source user's init script, if present, to pick up user-defined module and
# package paths
#
if {[file exists ~/.tcl/init.tcl]} {source ~/.tcl/init.tcl}

#
# project-specific configuration
#
set build_dir             ./build
set build_type            Release

# Set/used in CMakeLists.txt, do not change
set build_libname_file    libname.txt
set build_version_file    version.h
set build_version_var     PROJECT_VERSION

# modules are nested one level deep, e.g. act/mymodule
set project_module_root   act
set project_module_name   http

# build artifacts (incl. binaries) go in $build_dir/$project_package
set project_package       act_http

# ----------------------------------------------------------------------------

# default settings
array set opts {
    help         0
    verbose      0
    vcpkg_repo   https://github.com/microsoft/vcpkg
    dry_run      0
    packages     "packages.txt"
}

set commands {}

# read command line arguments
for {set i 0} {$i < $argc} {incr i} {
    set arg [lindex $argv $i]
    switch [lindex $argv $i] {
        "-h"           {set opts(help) 1}
        "-v"           {set opts(verbose) 1}
        "-vcpkg-repo"  -
        "--vcpkg-repo" {set opts(vcpkg_repo) [lindex $argv [incr i]]}
        "-dry-run"     -
        "--dry-run"    {set opts(dry_run) 1}
        "-packages"    -
        "--packages"   {set opts(packages) [lindex $argv [incr i]]}
        default {
            lappend commands [lindex $argv $i]
        }
    }
}

proc usage {} {
    set cmd_name [file tail $::argv0]
    puts [subst -nocommands \
         {Usage:    $cmd_name [-v] [--dry-run] [--vcpkg-repo] [--packages file] commands...}]
    puts "Commands:"
    puts "    cmake clean         Remove ./build directory."
    puts "    cmake release       Perform release build."
    puts "    system dir package  Print package installation path, if writable."
    puts "    system dir module   Print module installation path, if writable."
    puts "    system install package Copy built package to system's Tcl lib directory."
    puts "    system install module  Copy built module to system's Tcl module directory."
    puts "    vcpkg bootstrap     Perform one-time post-clone setup."
    puts "    vcpkg clone         Clone vcpkg repository."
    puts "    vcpkg install       Install required packages from package file."
    puts "    vcpkg setup         Perform initial setup: clone and bootstrap."
    puts "    vcpkg update        Perform git pull."
    puts ""
    puts "Command options: a single hypen may also be used to prefix extended options."
    puts "                 For example, -dry-run is the same as --dry-run."
    puts ""
}

if {$::opts(help)} {usage; exit 0}

proc verbose {msg} {if {$::opts(verbose)} {puts $msg}}

# ----------------------------------------------------------------------------

namespace eval util {}

proc util::exit_unless_git {} {
    if {[catch {exec git version}]} {
        puts "git is not installed or is not on your path. Exiting."
        exit 1
    }
}

proc util::is_windows {} {
    return [expr {$::tcl_platform(platform) eq "windows"}]
}

proc util::exit_unless_compiler {} {
    if {[util::is_windows]} {
        # It would be much easier if cl had a 'version' command
        if {[catch {exec -ignorestderr -- cl -help 2>@1}]} {
            puts "Could not find Microsoft Visual C++ Build Tools."
            puts "See https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-160"
            exit 1
        }

    } else {
        if {[catch {exec -- g++ --version}]} {
            puts "Could not find g++."
            exit 1
        }
    }
}

proc util::read_file {filename} {
    set f [open $filename r]
    set res [read -nonewline $f]
    close $f
    return $res
}

proc util::read_lines {filename} {
    set out {}
    set buf [read_file $filename]
    split $buf \n
}

proc util::get_define {filename define} {
    # return the string value after '#define $define' in $filename
    set in [read_lines $filename]
    foreach line $in {
        set r [regexp -all -inline {\S+} $line]
        if {[llength $r] < 3} { continue }
        if { [expr { [lindex $r 0] eq "#define" }] && \
             [expr { [lindex $r 1] eq $define   }]} {
            return [regexp -inline {[^"]+} [lindex $r 2]]
        }
    }
}

proc util::append_binary {source target} {
    # append the binary file $source to the end of $target, separated by SUB (^Z)

    set in  [open $source rb]
    set data [read $in]
    close $in

    set out [open $target ab]
    puts -nonewline $out \032
    puts -nonewline $out $data
    close $out
}

proc util::make_module {source target} {
    # make a module which will load $source when it is sourced
    # TODO: tmp file is locked open, is there a way to delete it on exit?
    global project_package
    set out [open $target w]
    puts $out "set project_package $project_package"
    puts $out {
        set path [info script]
        set f [open $path rb]
        while {![eof $f]} {
            set c [read $f 1]
            if {$c eq "\032"} { break }
        }
        set tmp [file tempfile tmp_name]
        fconfigure $tmp -translation binary
        fcopy $f $tmp
        close $tmp
        close $f
        load $tmp_name $project_package
    }
    close $out
    append_binary $source $target
}

proc util::make_zip_module {srcdir target} {
    global build_dir
    global project_package
    if {![file exists [file join $srcdir main.tcl]]} {
        # if no main.tcl exists in srcdir, provide a generic shared
        # library loader
        set f [open [file join $srcdir main.tcl] w]
        puts $f "set lib_name $project_package"
        puts $f {
            set root [file join [zipfs root] $lib_name]
            foreach lib [glob $root/*[info sharedlibextension]] {
                load $lib
            }
        }
        close $f
    }
    set zip [file tempfile tmp_name]
    close $zip
    zipfs mkzip $zip $srcdir $srcdir

    # write loader script, which mounts the zipfs archive and sources
    # main.tcl
    set out [open $target w]
    puts $out "set project_package $project_package"
    puts $out {
        set path [info script]
        set f [open $path rb]
        while {![eof $f]} {
            set c [read $f 1]
            if {$c eq "\032"} { break }
        }
        set tmp [file tempfile tmp_name]
        fconfigure $zip -translation binary
        fcopy $f $zip
        close $zip
        close $f

        zipfs mount $project_package $zip_name
        source [zipfs root]$project_package/main.tcl
    }
    close $out
    append_binary $zip $target
    file delete $zip
}

proc util::module_filename {} {
    global build_dir
    global build_version_file
    global build_version_var
    global project_module_name

    # read version (output by cmake)
    set vsn [util::get_define $build_dir/$build_version_file $build_version_var]

    # construct module file name
    set module_filename "$project_module_name-$vsn.tm"
    return $module_filename
}

proc util::find_lib {} {
    # find library artifact
    global build_dir
    global build_type
    global build_libname_file

    # read name of generated library (output by cmake)
    set libname [read_file $build_dir/$build_libname_file]

    set path $build_dir/$libname
    if {[file exists $path]} {
        return $path
    } else {
        set path $build_dir/$build_type/$libname
        if {[file exists $path]} {
            return $path
        } else {
            puts "ERROR: Could not find library artifact."
            exit 1
        }
    }
}

proc util::create_module {} {
    # After successful cmake build, create the tcl module file.
    # If zipfs is available,
    global build_dir
    global build_libname_file
    global build_version_file
    global build_version_var
    global project_module_root
    global project_module_name
    global project_package

    # read version (output by cmake)
    set vsn [util::get_define $build_dir/$build_version_file $build_version_var]

    # construct module file name
    set module_filename [module_filename]

    # create parent directory
    if {![file exists $build_dir/$project_module_root]} {
        file mkdir $build_dir/$project_module_root
    }

    # create module file
    set lib_path [find_lib]
    set module_path $build_dir/$project_module_root/$module_filename
    if {[file exists $module_path]} {file delete $module_path}

    # If zipfs is available, make a zip archive. If not, make a loader
    # which only loads a single binary.
    if {[catch {zipfs root}]} {
        util::make_module $lib_path $module_path
    } else {
        util::make_zip_module $build_dir/$project_package $module_path
    }
}

# ----------------------------------------------------------------------------

namespace eval vcpkg {
    # vcpkg directory location cannot be changed, because this would
    # require changing CMAKE_TOOLCHAIN_FILE, which isn't worth the
    # trouble for something designed to be turnkey.
    variable vcpkg_dir [file normalize [file join [pwd] .. vcpkg]]
}

proc vcpkg::clone {} {
    variable vcpkg_dir
    util::exit_unless_git

    if {$::opts(dry_run)} {
        puts "git clone $::opts(vcpkg_repo) $vcpkg_dir"
    } else {
        puts "Cloning vcpkg into $vcpkg_dir..."
        set res [exec -ignorestderr git clone $::opts(vcpkg_repo) $vcpkg_dir 2>@1]
        puts $res
    }
}

proc vcpkg::bootstrap {} {
    variable vcpkg_dir
    util::exit_unless_compiler

    if {[util::is_windows]} {
        set bootstrap [file join $vcpkg_dir bootstrap-vcpkg.bat]
    } else {
        set bootstrap [file join $vcpkg_dir bootstrap-vcpkg.sh]
    }
    if {$::opts(dry_run)} {
        puts $bootstrap
    } else {
        puts "Executing $bootstrap..."
        puts "Compiling may take several minutes with no output until complete..."
        set res [exec -ignorestderr $bootstrap 2>@1]
        puts $res
    }
}

proc vcpkg::setup {} {
    clone
    bootstrap
}

proc vcpkg::update {} {
    variable vcpkg_dir
    util::exit_unless_git
    set cmd "[file join $vcpkg_dir vcpkg]"

    if {$::opts(dry_run)} {
        puts "git -C $vcpkg_dir pull"
        puts "$cmd update"
    } else {
        puts "Performing git pull on $vcpkg_dir"
        set res [exec git -C $vcpkg_dir pull]
        puts $res
        puts "Performing vcpkg update"
        set res [exec -ignorestderr $cmd update 2>@1]
        puts $res
    }
}

proc vcpkg::install {} {
    variable vcpkg_dir
    if {![file exists $::opts(packages)]} {
        puts "ERROR: $::opts(packages) does not exist."
        exit 1
    }

    set packages [util::read_lines $::opts(packages)]
    ::verbose "Found in $::opts(packages): $packages"

    set cmd "[file join $vcpkg_dir vcpkg]"
    if {$::opts(dry_run)} {
        puts "$cmd install $packages"
    } else {
        puts "Installing packages from $::opts(packages)"
        puts "Compiling may take a long time with no output until complete..."
        puts "Consider executing this command manually instead:"
        puts "    $cmd install $packages"
        puts ""
        puts "Fetching and compiling..."
        set res [exec -ignorestderr $cmd install {*}$packages 2>@1]
        puts $res
    }
}

proc vcpkg::main {words} {
    switch [lindex $words 1] {
        "bootstrap" {bootstrap}
        "clone"     {clone}
        "install"   {install}
        "setup"     {setup}
        "update"    {update}
        default     {usage; exit 1}
    }
}

# ----------------------------------------------------------------------------

namespace eval cmake {}

proc cmake::clean {} {
    global build_dir
    file delete -force $build_dir
}

proc cmake::release {} {
    global build_dir
    global build_type

    exec -- cmake -S . -B $build_dir -DCMAKE_BUILD_TYPE=$build_type
    exec -- cmake --build $build_dir

    # create Tcl module from built library
    util::create_module
}

proc cmake::main {words} {
    switch [lindex $words 1] {
        "clean"    {clean}
        "release"  {release}
        default    {usage; exit 1}
    }
}

# ----------------------------------------------------------------------------

namespace eval system {
    global build_dir
    global project_module_root
    global project_package

    variable target_dir        [file normalize $build_dir/$project_package]
    variable target_module_dir [file normalize $build_dir/$project_module_root]
}

proc system::writable_lib {} {
    set scriptdir ""
    foreach dir $::auto_path {
        if {[file writable $dir]} {
            set scriptdir $dir
            break
        }
    }
    return $scriptdir
}

proc system::writable_module {} {
    set scriptdir ""
    foreach dir [::tcl::tm::path list] {
        if {[file writable $dir]} {
            set scriptdir $dir
            break
        }
    }
    return $scriptdir
}

proc system::tinstall {pathname} {
    if {[file isdirectory $pathname] == 0} {
        puts "ERROR: $pathname must be a directory."
        exit 1
    }

    set scriptdir [writable_lib]

    if {$scriptdir eq ""} {
        puts "Could not write to any path in auto_path: $::auto_path"
        exit 1
    }

    set path_tail [file tail $pathname]
    if {$path_tail ne "" && [file exists $scriptdir/$path_tail]} {
        file delete -force $scriptdir/$path_tail
    }
    puts "Copying $pathname to $scriptdir/$path_tail"
    file copy -force $pathname $scriptdir
}

proc system::tinstall_module {pathname} {
    if {[file isdirectory $pathname] == 0} {
        puts "ERROR: $pathname must be a directory."
        exit 1
    }

    set scriptdir [writable_module]

    if {$scriptdir eq ""} {
        puts "Could not write to any path in ::tcl::tm::path list: [::tcl::tm::path list]"
        exit 1
    }

    set path_tail [file tail $pathname]
    if {$path_tail ne "" && [file exists $scriptdir/$path_tail]} {
        file delete -force $scriptdir/$path_tail
    }
    puts "Copying $pathname to $scriptdir/$path_tail"
    file copy -force $pathname $scriptdir
}

proc system::install_package {} {
    variable target_dir
    if {![file exists $target_dir]} {
        puts "ERROR: Could not find package. "
        puts "Consider first running $::argv0 cmake release"
        exit 1
    }

    tinstall $target_dir
}

proc system::install_module {} {
    variable target_module_dir
    if {![file exists $target_module_dir]} {
        puts "ERROR: Could not find module. "
        puts "Consider first running $::argv0 cmake release"
        exit 1
    }

    tinstall_module $target_module_dir
}


proc system::main {words} {
    switch [lindex $words 1] {
        install  {switch [lindex $words 2] {
            package {install_package}
            module  {install_module}
            default {usage; exit 1}
        }}

        dir {switch [lindex $words 2] {
            package {puts [writable_lib]}
            module  {puts [writable_module]}
            default {usage; exit 1}
        }}

        default  {usage; exit 1}
    }
}

# require git
verbose {Checking output of 'git version'... }
util::exit_unless_git
verbose {Checking for C compiler...}
util::exit_unless_compiler

verbose "Command words: $commands"
verbose "Options:"; if {$::opts(verbose)} {parray opts}


if {[llength $commands] > 0} {
    switch [lindex $commands 0] {
        "cmake"  {cmake::main $commands}
        "system" {system::main $commands}
        "vcpkg"  {vcpkg::main $commands}
        default {usage; exit 1}
    }
} else {
    usage ;# no exit, to allow loading from interactive session
}
